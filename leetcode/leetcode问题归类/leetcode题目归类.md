# 背包问题

参考资料：[背包九讲](http://www2.lssh.tp.edu.tw/~hlf/class-1/lang-c/DP.pdf)

### P01: 01背包问题

有 N 件物品和一个容量为 V 的背包，第 i 件物品的费用是 c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

特点：每种物品只有一件，可以选择放或者不放

状态：f[i][v]表示前 i 件物品恰放入一個容量为 v 的背包可以获得的最大价值。  
状态转移：$f[i][v]=\max(f[i-1][v],f[i-1][v-c[i]]+w[i])$

空间优化(注意第二个for是逆序的)：

```python
for i=1..N
    for v=V..0
        f[v]=max{f[v],f[v-c[i]]+w[i]}
```

### P02: 完全背包问题

有 N 种物品和一個容量为 V 的背包，每种物品都有无限件可用。 第 i 种物品的费用是 c[i]，价值是 w[i]。 求解将哪些物品裝入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

特点：每种物品有无限件

* 如果根据01背包问题定义状态：f[i][v]表示前 i 种物品恰放入一個容量为 v 的背包的最大价值。  
状态转移：$f[i][v]=\max(f[i-1][v-k*c[i]]+k*w[i],0<=k*c[i]<=v)$  

* 转化成01背包问题，将第 i 种物品分成O(log V/c[i]) 件。因为不管最优策略选择几件第 i 种物品，总可以表示成若干个$2^k$的和。

* 实际上我们维护一个当前最大价值的数组，按顺序加入新物品：

```python
for i=1..N
    for v=c[i],..V
        f[v]=max{f[v],f[v-c[i]]+w[i]}
```

### P03: 多重背包问题

有 N 种物品和一個容量为 V 的背包。第 i 种物品最多有 n[i]件可用， 每件费用是 c[i]，价值是 w[i]。求解将哪些物品裝入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。  

特点：对物品件数进行了限制。  

* 如果根据01背包问题定义状态：f[i][v]表示前 i 种物品恰放入一個容量为 v 的背包的最大价值。  
状态转移：$f[i][v]=\max(f[i-1][v-k*c[i]]+k*w[i],0<=k*c[i]<=min(v,n[i]))$  

* 将第i中物品分成O(log(n[i]))件，$1,2,4,...,2^{(k-1)},n[i]-2^k+1,$ 保证$n[i]-2^k+1>0$。比如13，分为1，2，4，6，然后费用也随着翻倍就ok。$2^k-1$是前面$1,2,4,...,2^{k-1}$的和。

### P04: 混合三种背包问题

将 P01、P02、P03 混合起來。也就是说，有的物品只可以取 一次(01 背包)，有的物品可以取无限次(完全背包)，有的物品可以取的次数有一个上限(多重背包)。那就用前面三种解法组合起来求解。

### P05: 二维费用的背包问题
二维费用的背包问题是指:对于每件物品，具有两种不同的费用; 选择这件物品必须同时付出这两种代价;对于每种代价都有一个可付出的最大值(背包容量)。问怎么选择物品可以得到最大的价值。  

设这两种代价分别为代价1 和代价2，第 i 件物品所需的两种代价分別为 a[i] 和 b[i]。两种代价可付出的最大值(两种背包容量)分別为 V 和 U，物品的价值为 w[i]。

费用加了一维，只需状态也加一维即可。  
状态：f[i][v][u]表示前 i 件物品付出两种代价分别 v 和 u 時可获得的最大价值。
状态转移方程：$f[i][v][u]=max(f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i])$

第二纬度的限制可以是物品总个数的限制等。

### P06: 分组的背包问题

有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 c[i]，价值是 w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品裝入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

状态：f[k][v]表示前 k 组物品花费费用 v 能取得的最大价值。  
状态转移：$f[k][v]=max(f[k-1][v],f[k-1][v-c[i]]+w[i], 物品 i \in 組 k)$

### P07: 有依赖的背包问题

这种背包问题的物品间存在某种依赖的关系，。也就是说，i 依赖于j，表示若选择物品i， 则必须选择物品j。 为了简化起见，我们先设没有某种物品既依赖于别的物品又被别的物品所依赖。另外，没有某件物品同时依赖多件物品。

考虑将一个主件（没有依赖别的物品）和它的附件（依赖主件）集合作为一个物品组，对主件i的附件集合进行01背包得到费用依次为0..V-c[i]时相应的最大价值 f'[0..V-c[i]]。那么这个主件及它的附件集合相当于 V-c[i]+1 个物品的物品组。

如果允许附件可以有自己的子件集合，限制只是每个物品最多只依赖于一个物品且不出现循环依赖。 那么一个物品组之间的依赖关系就是树形结构。

### P08: 泛化物品

在背包容量为 V 的背包问题中，泛化物品是一个 定义域为 0..V 中的整数的函数 h，当分配給它的费用为 v 时，能得到的价值就是 h(v)。

### P09: 背包问题问法的变化

以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法。

* 输出方案。  
  可以用一个数组 g[i][v]，设 g[i][v]=0 表示推出 f[i][v]的值时是采用了方程的前一项(也即 f[i][v]=f[i-1][v])，g[i][v]表示采用了方程的后一项。

```python
i=N
v=V
while(i>0):
    if(g[i][v]==0)
        print "未選第 i 項物品"
    elif(g[i][v]==1)
        print "選了第 i 項物品" v=v-c[i]
    i-=1
```

* 输出方案总数  
  状态转移的max改成sum
* 最优方案的总数  
  最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数

```python
for i=1..N
    for v=0..V
        f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
        g[i][v]=0
        if(f[i][v]==f[i-1][v])
            g[i][v]+=g[i-1][v]
        if(f[i][v]==f[i-1][v-c[i]]+w[i])
            g[i][v]+=g[i-1][v-c[i]]
```

* 求次优解，第K优解  
  在原來的方程中加上一维，f[i][v][K]为前i个物品费用最多为v的第K优解。（维护一个最小堆）
