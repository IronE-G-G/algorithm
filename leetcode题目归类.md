# leetcode题目归类

## 数组

* **lc-1 两数之和（简单）**
  * 暴力        🍏
  * 哈希表      🍎
* **lc-4 寻找两个有序数组的中位数（困难）**
  * 先排好序，再求中位数    🍎
  * 直接在两个数组上线性搜索中位数  🍏
  * 尾递归寻找第k个数   🍏
  * 利用中位数两边数量相等的性质    🍏
* **lc-15 三数之和 （中等）**
  * 暴力    🍎
  * 排序+双指针     🍎
* **lc-53 最大子序和（简单）**
  * 暴力1   🍎
  * 暴力2   🍎
  * dp  🍎
* **lc-42 接雨水（困难）**
  * 暴力     🍎
  * dp保存leftmax和rightmax     🍎
* **lc-11 盛水最多的容器（中等）**
  * 暴力     🍎
  * 双指针法    🍏
* **lc-85 最大矩形（困难）**
  * 暴力+dp  🍎
  * 借鉴lc-84的做法 🍏
* **lc-84 柱状图中最大的矩形（困难）**
  * 暴力 🍎
  * 以柱子i为最小的柱子，左右寻找比他小的柱子作为边界（维护两个栈） 🍏
  * 维护一个栈  🍏
* **lc-16 最接近的三数之和（中等）**
  * 暴力 🍎
  * 双指针 🍎
* **lc-31 下一个排列（中等）**
  * 找规律 🍎
* **lc-26 删除排序数组中的重复项（简单）**
  * 暴力，反向pop：这个其实很不好，list的pop复杂度O(n)  🍎
  * 双指针 🍎
* **lc-717 1比特与2比特字符（简单）**
  * 找规律  🍎
* **lc-59 螺旋矩阵ii（中等）**
  * 过程模拟    🍎
* **lc-78 子集（中等）**
  * 回溯 🍎
  * 迭代  🍎
* **lc-39 组合总和（中等）--完全背包问题**
  * 回溯+剪枝  🍎
  * 迭代 🍏
* **lc-45 跳跃游戏ii（困难）**
  * 回溯+剪枝 🍎
  * dp  🍎
  * 贪心算法  🍎
* **lc-121 买卖股票的最佳时机（简单）**
  * 暴力  🍎
  * 动态规划 (dpi维护第i-1天之前买入的最低价格) 🍎
* **lc-88 合并两个有序数组（简单）**
  * 合并后排序  🍏
  * 双指针+后向遍历  🍎
* **lc-18 四数之和（中等）**
  * 排序+双指针 🍎
* **lc-118 杨辉三角（简单）**
  * 迭代  🍎
* **lc-64 最小路径和 （中等）**
  * 动态规划 🍎
* **lc-56 合并区间（中等）**
  * 排序+维护结果 🍎
* **lc-561 数组拆分i（简单）**
  * 排序   🍎
  * 哈希索引  🍏
* **lc-128 最长连续序列（困呐）**
  * 排序+遍历  🍎
  * 哈希  🍎
* **lc-120 三角形最小路径和（中等）**
  * 动态规划 🍎
* **lc-167 两数之和ii-输入有序数组（简单）**
  * 暴力  🍎
  * 哈希  🍎
  * 有序-->双指针 🍎
* **lc-442 数组中重复的数据（中等）**
  * 排序+遍历 🍎
  * 集合  🍎
  * 位置作为索引，节省空间  🍎
* **lc-48 旋转图像（中等）**
  * 模拟旋转+临时空间O(n)  🍎
  * 转置+行逆 🍏
* **lc-289 生命游戏（中等）**
  * 额外空间 🍎
  * 原地算法 🍏
* **lc-105 从前序与中序遍历序列构造二叉树（中等）**
  * 递归  🍎
* **lc-238 除自身以外数组的乘积（中等）**
  * 暴力 🍎
  * 左右各自扫描一次  🍎
* **lc-41缺失的第一个正数（困难）**
  * 哈希表  🍎
  * 原地索引  🍎
* **lc-287 寻找重复数（中等）**
  * 排序 🍎
  * 哈希 🍎
  * 原地索引 🍎
* **lc-621 任务调度器（中等）**
  * 每取一轮排一次序 🍎
  * 只要最长的能排满，就等于任务总数 🍏
* **lc-718 最长重复子数组（中等）**
  * 哈希表+暴力O（MNmin(M,N)） 🍏
  * 动态规划，dp[i][j]，A[i],B[j]的最长前缀 🍏
* **lc-54 螺旋矩阵（中等）**
  * 模拟 🍎
* **lc-941 有效的山脉数组（简单）**
  * 模拟上下山 🍎
* **lc-300 最长上升子序列（中等）**
  * 动态规划，以元素i结尾的最长上升子序列 🍎
  * 动态规划+二分法，维护tails[i]，长度为i+1的最小结尾元素 🍏
* **lc-560 和为k的子数组（中等）**
  * 暴力 🍎
  * 哈希 🍏
* **lc-122 买卖股票的最佳时期ii（简单）**
  * 动态规划 🍎
* **lc-747 至少是其他数字两倍的最大数（简单）**
  * 线性扫描 🍎





* **lc-75 颜色分类（中等）**
  * 计数排序 🍎
  * 双指针 🍏
* **lc-78 子集（中等）**
  * 回溯 🍎
  * 迭代 🍎
* **lc-79 单词搜索（中等）**
  * dfs 🍎
* **lc-80 删除排序数组中的重复项ii（中等）**
  * 暴力pop 🍎
  * 指针记录  🍎
* **lc-33 搜索旋转排序数组（中等）**
  * 二分法，找出有序的部分 🍎
* **lc-81 搜索旋转排序数组ii（中等）**
  * 二分法，找出有序部分，如果开头跟mid一样，continue 🍏
* **lc-84 柱状图最大的矩形（困难）**
  * 暴力 🍎
  * 栈方法 🍎
* **lc-85 最大矩形（困难）**
  * 暴力 🍎
  * 栈方法 🍎
* **lc-88 合并两个有序数组（简单）**
  * 暴力 🍎
  * 双指针+后续遍历 🍎
* **lc-90 子集ii（中等）**
  * 回溯(是否有下一个 and 下一个加入哪个)  🍎


## 背包问题

参考资料：[背包九讲](http://www2.lssh.tp.edu.tw/~hlf/class-1/lang-c/DP.pdf)

### P01: 01背包问题

有 N 件物品和一个容量为 V 的背包，第 i 件物品的费用是 c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

特点：每种物品只有一件，可以选择放或者不放

状态：f[i][v]表示前 i 件物品恰放入一個容量为 v 的背包可以获得的最大价值。  
状态转移：$f[i][v]=\max(f[i-1][v],f[i-1][v-c[i]]+w[i])$

空间优化(注意第二个for是逆序的)：

```python
for i=1..N
    for v=V..0
        f[v]=max{f[v],f[v-c[i]]+w[i]}
```

### P02: 完全背包问题

有 N 种物品和一個容量为 V 的背包，每种物品都有无限件可用。 第 i 种物品的费用是 c[i]，价值是 w[i]。 求解将哪些物品裝入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

特点：每种物品有无限件

* 如果根据01背包问题定义状态：f[i][v]表示前 i 种物品恰放入一個容量为 v 的背包的最大价值。  
状态转移：$f[i][v]=\max(f[i-1][v-k*c[i]]+k*w[i],0<=k*c[i]<=v)$  

* 转化成01背包问题，将第 i 种物品分成O(log V/c[i]) 件。因为不管最优策略选择几件第 i 种物品，总可以表示成若干个$2^k$的和。

* 实际上我们维护一个当前最大价值的数组，按顺序加入新物品：

```python
for i=1..N
    for v=c[i],..V
        f[v]=max{f[v],f[v-c[i]]+w[i]}
```

### P03: 多重背包问题

有 N 种物品和一個容量为 V 的背包。第 i 种物品最多有 n[i]件可用， 每件费用是 c[i]，价值是 w[i]。求解将哪些物品裝入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。  

特点：对物品件数进行了限制。  

* 如果根据01背包问题定义状态：f[i][v]表示前 i 种物品恰放入一個容量为 v 的背包的最大价值。  
状态转移：$f[i][v]=\max(f[i-1][v-k*c[i]]+k*w[i],0<=k*c[i]<=min(v,n[i]))$  

* 将第i中物品分成O(log(n[i]))件，$1,2,4,...,2^{(k-1)},n[i]-2^k+1,$ 保证$n[i]-2^k+1>0$。比如13，分为1，2，4，6，然后费用也随着翻倍就ok。$2^k-1$是前面$1,2,4,...,2^{k-1}$的和。

### P04: 混合三种背包问题

将 P01、P02、P03 混合起來。也就是说，有的物品只可以取 一次(01 背包)，有的物品可以取无限次(完全背包)，有的物品可以取的次数有一个上限(多重背包)。那就用前面三种解法组合起来求解。

### P05: 二维费用的背包问题
二维费用的背包问题是指:对于每件物品，具有两种不同的费用; 选择这件物品必须同时付出这两种代价;对于每种代价都有一个可付出的最大值(背包容量)。问怎么选择物品可以得到最大的价值。  

设这两种代价分别为代价1 和代价2，第 i 件物品所需的两种代价分別为 a[i] 和 b[i]。两种代价可付出的最大值(两种背包容量)分別为 V 和 U，物品的价值为 w[i]。

费用加了一维，只需状态也加一维即可。  
状态：f[i][v][u]表示前 i 件物品付出两种代价分别 v 和 u 時可获得的最大价值。
状态转移方程：$f[i][v][u]=max(f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i])$

第二纬度的限制可以是物品总个数的限制等。

### P06: 分组的背包问题

有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 c[i]，价值是 w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品裝入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

状态：f[k][v]表示前 k 组物品花费费用 v 能取得的最大价值。  
状态转移：$f[k][v]=max(f[k-1][v],f[k-1][v-c[i]]+w[i], 物品 i \in 組 k)$

### P07: 有依赖的背包问题

这种背包问题的物品间存在某种依赖的关系，。也就是说，i 依赖于j，表示若选择物品i， 则必须选择物品j。 为了简化起见，我们先设没有某种物品既依赖于别的物品又被别的物品所依赖。另外，没有某件物品同时依赖多件物品。

考虑将一个主件（没有依赖别的物品）和它的附件（依赖主件）集合作为一个物品组，对主件i的附件集合进行01背包得到费用依次为0..V-c[i]时相应的最大价值 f'[0..V-c[i]]。那么这个主件及它的附件集合相当于 V-c[i]+1 个物品的物品组。

如果允许附件可以有自己的子件集合，限制只是每个物品最多只依赖于一个物品且不出现循环依赖。 那么一个物品组之间的依赖关系就是树形结构。

### P08: 泛化物品

在背包容量为 V 的背包问题中，泛化物品是一个 定义域为 0..V 中的整数的函数 h，当分配給它的费用为 v 时，能得到的价值就是 h(v)。

### P09: 背包问题问法的变化

以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法。

* 输出方案。  
  可以用一个数组 g[i][v]，设 g[i][v]=0 表示推出 f[i][v]的值时是采用了方程的前一项(也即 f[i][v]=f[i-1][v])，g[i][v]表示采用了方程的后一项。

```python
i=N
v=V
while(i>0):
    if(g[i][v]==0)
        print "未選第 i 項物品"
    elif(g[i][v]==1)
        print "選了第 i 項物品" v=v-c[i]
    i-=1
```

* 输出方案总数  
  状态转移的max改成sum
* 最优方案的总数  
  最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数

```python
for i=1..N
    for v=0..V
        f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
        g[i][v]=0
        if(f[i][v]==f[i-1][v])
            g[i][v]+=g[i-1][v]
        if(f[i][v]==f[i-1][v-c[i]]+w[i])
            g[i][v]+=g[i-1][v-c[i]]
```

* 求次优解，第K优解  
  在原來的方程中加上一维，f[i][v][K]为前i个物品费用最多为v的第K优解。（维护一个最小堆）
